# frozen_string_literal: true

# Rakefile
require 'yaml'
require 'rake'
require 'uri'
require 'zlib'
require 'fileutils'
require 'aspera/environment'
require_relative '../package/build_tools'
require_relative '../package/folders'

include Folders
include BuildTools

TEST_DEFS  = TST / 'tests.yml'
STATE_FILE = TMP / 'state.yml'

# override $HOME/.aspera/ascli
CLI_HOME = TMP / "#{Aspera::Cli::Info::CMD_NAME}_home"
CLI_PATH = BIN / Aspera::Cli::Info::CMD_NAME

GOOD_CONFIG = Pathname.new(ENV['ASPERA_CLI_TEST_CONF_FILE'])
# default download folder for Connect Client (used to cleanup and avoid confirmation from connect when overwrite)
DIR_CONNECT_DOWNLOAD = Pathname.new(Dir.home) / 'Downloads'
# package title for faspex and aoc
PACKAGE_TITLE_BASE = Time.now.to_s
# give waring and stop on first warning in this gem code
RUBY_WARN = ['ruby', '-w', TST / 'warning_exit_wrapper.rb']
# CLI with default config file
CLI_NOCONF = RUBY_WARN + [CLI_PATH, "--home=#{CLI_HOME}"]
# "CLI_TEST" is used to call the tool in the testing environment
CLI_TEST = CLI_NOCONF + ["--config-file=#{GOOD_CONFIG}"]
# JRuby does not support some encryptions
CLI_TEST.push('-Pjns') if defined?(JRUBY_VERSION)
# temp configuration file that is modified, to avoid changing the main configuration file
TEST_CONFIG = TMP / 'sample.conf'
# "CLI_TMP_CONF" is used for commands that modify the config file
CLI_TMP_CONF = CLI_NOCONF + ["--config-file=#{TEST_CONFIG}"]
# testing file generated locally (special shell characters must be escaped for shell, special makefile characters escaped)
TST_ASC_FILENAME = 'data_file.bin'
TST_ASC_LCL_PATH = TMP / TST_ASC_FILENAME
# This file name contains special characters, it must be quoted when used in shell
# cspell:disable-next-line
TST_UTF_FILENAME = 'ð’«spÃ©cial{\#ðŸ˜€Øªãƒ„'
TST_UTF_LCL_PATH = TMP / TST_UTF_FILENAME
# a medium sized file for testing
TST_MED_FILENAME = TST_UTF_FILENAME
# needs to be quoted, as there is shell special character: "?"
TST_MED_LCL_PATH = "faux:///#{URI.encode_www_form_component(TST_MED_FILENAME)}?100m"

TEMPORIZE_CREATE = 10
TEMPORIZE_FILE = 30
# sync dir must be an absolute path, but tmp dir may not exist yet, while its enclosing folder should exist
TMP_SYNCS = TMP / 'syncs'

SHARES_SYNC = TMP_SYNCS / 'shares_sync'
TST_LCL_FOLDER = TMP_SYNCS / 'sendfolder'

TMP_STATES = TMP / 'states'

VAULT_FILE = TOP / 'tmp/sample_vault.bin'
NEW_VAULT_PASS = 'my_other_pass_here'
PKCS_P = 'YourExportPassword'

FILE_LIST = TMP / 'filelist.txt'
FILE_PAIR = TMP / 'file_pair_list.txt'

FileUtils.cp(GOOD_CONFIG, TEST_CONFIG) unless TEST_CONFIG.exist?
TST_ASC_LCL_PATH.write('This is a small test file') unless  TST_ASC_LCL_PATH.exist?
TST_UTF_LCL_PATH.write('This is a small test file') unless  TST_UTF_LCL_PATH.exist?

FILE_LIST.write("#{TST_ASC_LCL_PATH}")
# @preset:server.inside_folder@/other_name
FILE_PAIR.write("#{TST_ASC_LCL_PATH}\n/Upload/server_folder/other_name")

FileUtils.mkdir_p(SHARES_SYNC)
FileUtils.mkdir_p(TMP_STATES)
(SHARES_SYNC / 'sample_file.txt').write('Some sample file')
FileUtils.mkdir_p(TST_LCL_FOLDER / 'sub')
%w[1 2 3 sub/1 sub/2].each do |f|
  (TST_LCL_FOLDER / f).write('Some sample file')
end

# Source - https://stackoverflow.com/a/55705853
# Posted by user3592693, modified by community. See post 'Timeline' for change history
# Retrieved 2025-12-01, License - CC BY-SA 4.0

def safe_load_yaml(file_or_content)
  yaml = file_or_content.is_a?(File) ? file_or_content.read : file_or_content
  duplicate_keys = []
  validator = ->(node, parent_path) do
    if node.is_a?(Psych::Nodes::Mapping)
      # In a Mapping, every other child is the key node, the other is the value node.
      children = node.children.each_slice(2)
      duplicates = children.map{ |key_node, _value_node| key_node}.group_by(&:value).select{ |_value, nodes| nodes.size > 1}
      duplicates.each do |key, nodes|
        duplicate_key = {
          file:        (file_or_content.path if file_or_content.is_a?(File)),
          key:         parent_path + [key],
          occurrences: nodes.map{ |occurrence| "line: #{occurrence.start_line + 1}"}
        }.compact
        duplicate_keys << duplicate_key
      end
      children.each{ |key_node, value_node| validator.call(value_node, parent_path + [key_node.value].compact)}
    else
      node.children.to_a.each{ |child| validator.call(child, parent_path)}
    end
  end
  ast = Psych.parse_stream(yaml)
  validator.call(ast, [])
  raise "Duplicate keys: #{duplicate_keys}" unless duplicate_keys.empty?
  YAML.safe_load(yaml)
end

tests = safe_load_yaml(TEST_DEFS.read)
# tests      = YAML.load_file(TEST_DEFS)
state = STATE_FILE.exist? ? YAML.load_file(STATE_FILE) : {}

def save_state(state)
  File.write(STATE_FILE, state.to_yaml)
end

def eval_macro(value)
  # value.gsub(/\$\((.*?)\)/) do
  value.gsub(/\$\((?<inner>(?:[^()]+|\((?:[^()]+|\g<inner>)*\))*)\)/) do
    Aspera::Environment.secure_eval(Regexp.last_match(1), __FILE__, __LINE__).to_s
  end
  # puts "Eval: #{value} -> [#{x}]"
end

def pid_file(name)
  TMP_STATES / "#{name}.pid"
end

def out_file(name)
  TMP_STATES / "#{name}.out"
end

def read_value_from(name)
  state_file = out_file(name)
  value = state_file.read.chomp
  puts("Read: #{state_file}: #{value}")
  value
end

def stop_process(name)
  pid = pid_file(name).read.to_i
  Process.kill('TERM', pid)
  Process.wait(pid)
end

def check_process(name)
  pid = pid_file(name).read.to_i
  r = Process.kill(0, pid)
  puts("Kill 0 : #{r}")
end

namespace :test do
  # List tests with metadata
  desc 'List all tests with tags'
  task :list do
    tests.each do |name, info|
      puts "#{name.ljust(20)} #{info['tags']&.join(', ')}"
    end
  end

  desc 'Skip a given test by name'
  task :skip do
    ENV['T'].split(',').each do |k|
      state[k] = 'skipped'
      puts "[SKIP] #{k}"
    end
    save_state(state)
  end

  desc 'Clear a given test by name'
  task :clear do
    ENV['T'].split(',').each{ |k| state.delete(k)}
    save_state(state)
    puts "[CLEAR] #{ENV['T']}"
  end

  # Reset persistent state
  desc 'Clear all stored test results'
  task :reset do
    STATE_FILE.delete if STATE_FILE.exist?
    TEST_CONFIG.delete if TEST_CONFIG.exist?
    puts 'State cleared.'
  end

  # Run tests filtered by tag
  desc 'Run only tests matching tag'
  task :tags, [:tag] do |_, args|
    tag = args[:tag]
    abort 'Usage: rake test:tags[download]' unless tag

    selected = tests.select{ |_, info| info['tags']&.include?(tag)}
    Rake::Task['test:run'].invoke if selected.empty?

    selected.each_key do |name|
      Rake::Task["test:#{name}"].invoke
    end
  end

  # Create a Rake task for each test
  tests.each do |name, info|
    # puts "-> #{name}"
    desc info['description'] || 'TODO'

    deps = info['depends_on'] || []
    task name => deps.map{ |d| "test:#{d}"} do
      if %w[passed skipped].include?(state[name]) && !ENV['FORCE']
        # puts "[SKIP] #{name}"
        next
      end
      puts "[RUN]  #{name}: #{info['command']&.join(' ')}"
      info['pre']&.each do |cmd|
        puts("Executing: #{cmd}")
        Aspera::Environment.secure_eval(cmd, __FILE__, __LINE__)
      end
      must_fail = info['tags']&.include?('must_fail')
      hide_fail = info['tags']&.include?('hide_fail')
      ignore_fail = info['tags']&.include?('ignore_fail')
      save_output = info['tags']&.include?('save_output') || info['expect']
      wait_non_empty_output = info['tags']&.include?('wait_non_empty_output')
      tmp_conf = info['tags']&.include?('tmp_conf')
      if info['command'].include?('wizard')
        info['env'] ||= {}
        info['env']['ASCLI_WIZ_TEST'] = 'yes'
      end
      loop do
        if info['reset_folder']
          folder = eval_macro(info['reset_folder'])
          FileUtils.rm_rf(folder)
          FileUtils.mkdir_p(folder)
        end
        full_args = CLI_TEST
        full_args = CLI_TMP_CONF if info['command'][0..1].eql?(%w[config wizard]) || tmp_conf
        full_args += info['command'].map{ |i| eval_macro(i.to_s)}
        full_args += ["--output=#{out_file(name)}"] if save_output
        kwargs = {}
        if info['tags']&.include?('noblock')
          kwargs['background'] = true
          full_args.push("--pid-file=#{pid_file(name)}")
        end
        if info['stdin']
          stdinfile = TMP / "#{name}.stdin"
          input = eval_macro(info['stdin'])
          stdinfile.write(input)
          kwargs[:in] = stdinfile.to_s
          puts("Input: #{input}")
        end
        run(*full_args, env: info['env'], **kwargs)
        info['post']&.each do |cmd|
          puts("Executing: #{cmd}")
          Aspera::Environment.secure_eval(cmd, __FILE__, __LINE__)
        end
        puts("Saved: #{out_file(name).read}") if save_output
        next if wait_non_empty_output && out_file(name).empty?
        if info['expect']
          raise "not match[#{info['expect']}][#{out_file(name).read}]" unless info['expect'].eql?(out_file(name).read.chomp)
        end
        state[name] = 'passed'
        raise 'Must fail' if must_fail
        puts "[OK]   #{name}"
        break
      rescue RuntimeError
        puts "[FAIL] #{name}"
        state[name] = 'failed'
        if must_fail || hide_fail || ignore_fail
          state[name] = 'passed'
        else
          raise
        end
        save_state(state)
        break
      end
      save_state(state)
    end
  end

  # Run all tests in declared order
  desc 'Run all tests'
  task :run do
    tests.each_key{ |name| Rake::Task["test:#{name}"].invoke}
  end
end

# default: run all tests
task default: 'test:run'

# TODO: separately in rake task
# asession:
#	set -x&&\
#	remote_host=$$( config preset get server_user url)&&\
#	remote_host=$${remote_host#*://}&&\
#	remote_port=$${remote_host#*:}&&\
#	remote_host=$${remote_host%:*}&&\
#	remote_user=$$( config preset get server_user username)&&\
#	remote_pass=$$( config preset get server_user password)&&\
#	$(DIR_BIN)asession @json:@extend:{"loglevel":"info","spec":{"remote_host":"'"$${remote_host}"'","remote_user":"'"$${remote_user}"'","ssh_port":'$${remote_port}',"remote_password":"'"$${remote_pass}"'","direction":"receive","destination_root":"$(TMP)","resume_policy":"none","paths":[{"source":"/aspera-test-dir-large/100MB"}]}}
